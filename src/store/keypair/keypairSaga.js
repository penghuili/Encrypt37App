import { all, call, fork, put, select, takeLatest } from 'redux-saga/effects';

import { decryptText, encryptText, generateKeyPair, isValidPublicKey } from '../../lib/encryption';
import { LocalStorage, LocalStorageKeys } from '../../lib/localstorage';
import { navigationRef } from '../../router/navigationRef';
import { routeNames } from '../../router/routes';
import { toastActionCreators } from '../toast/toastActions';
import { keypairActionCreators, keypairActionTypes } from './keypairActions';
import { keypairSelectors } from './keypairSelectors';

function* initKeys() {
  const privateKey = yield call(LocalStorage.get, LocalStorageKeys.privateKey);
  if (privateKey) {
    yield put(keypairActionCreators.setPrivateKey(privateKey.trim()));
  }

  const publicKey = yield call(LocalStorage.get, LocalStorageKeys.publicKey);
  if (publicKey) {
    yield put(keypairActionCreators.setPublicKey(publicKey.trim()));
  }

  const publicKeys = yield call(LocalStorage.get, LocalStorageKeys.publicKeys);
  if (publicKeys?.length) {
    yield put(keypairActionCreators.setPublicKeys(publicKeys));
  }

  const activePublicKey = yield call(LocalStorage.get, LocalStorageKeys.activePublicKey);
  if (activePublicKey) {
    yield put(keypairActionCreators.setActivePublicKey(activePublicKey));
  }

  const hasDoneBackup = yield call(LocalStorage.get, LocalStorageKeys.hasDoneBackup);
  yield put(keypairActionCreators.setBackup(!!hasDoneBackup));

  yield put(keypairActionCreators.finishLoading());
}

function* handleNavigateToNewKeypairPressed() {
  yield call(navigationRef.navigate, routeNames.newKeypair);
}

function* handleNavigateToExistingKeypairPressed() {
  yield call(navigationRef.navigate, routeNames.existingKeypair);
}

function* handlePastePublicKeyPressed({ payload: { publicKey } }) {
  if (!publicKey) {
    return;
  }

  const trimmed = publicKey.trim();
  yield call(LocalStorage.set, LocalStorageKeys.publicKey, trimmed);
  yield put(keypairActionCreators.setPublicKey(trimmed));
}

function* handlePastePrivateKeyPressed({ payload: { privateKey } }) {
  if (!privateKey) {
    return;
  }

  const trimmed = privateKey.trim();
  yield call(LocalStorage.set, LocalStorageKeys.privateKey, trimmed);
  yield put(keypairActionCreators.setPrivateKey(trimmed));
}

function* handleFinishAddExistingKeypairPressed() {
  const publicKey = yield select(keypairSelectors.getPublicKey);
  const { data: encrypted } = yield call(encryptText, 'test', publicKey);
  if (!encrypted) {
    yield put(toastActionCreators.setToast('Provide a valid key pair that generated by this app.'));
    return;
  }

  const privateKey = yield select(keypairSelectors.getPrivateKey);
  const { data: decrypted } = yield call(decryptText, encrypted, privateKey);
  if (decrypted !== 'test') {
    yield put(toastActionCreators.setToast('Provide a valid key pair that generated by this app.'));
    return;
  }

  yield call(handleFinishBackupPressed);
}

function* handleGenerateKeypairPressed() {
  const keypair = yield call(generateKeyPair);
  yield call(LocalStorage.set, LocalStorageKeys.privateKey, keypair.privateKey);
  yield call(LocalStorage.set, LocalStorageKeys.publicKey, keypair.publicKey);
  yield put(keypairActionCreators.setPrivateKey(keypair.privateKey));
  yield put(keypairActionCreators.setPublicKey(keypair.publicKey));
}

function* handleDeleteKeypairPressed() {
  yield call(navigationRef.navigate, routeNames.confirmDeleteKeys);
}

function* handleConfirmDeleteKeypairPressed() {
  yield call(LocalStorage.remove, LocalStorageKeys.privateKey);
  yield call(LocalStorage.remove, LocalStorageKeys.publicKey);
  yield call(LocalStorage.remove, LocalStorageKeys.publicKeys);
  yield call(LocalStorage.remove, LocalStorageKeys.activePublicKey);
  yield call(LocalStorage.remove, LocalStorageKeys.hasDoneBackup);
  yield put(keypairActionCreators.setPrivateKey(''));
  yield put(keypairActionCreators.setPublicKey(''));
  yield put(keypairActionCreators.setPublicKeys([]));
  yield put(keypairActionCreators.setActivePublicKey(null));
  yield put(keypairActionCreators.setBackup(false));

  yield put(toastActionCreators.setToast('Key pair is deleted.'));
}

function* handleFinishBackupPressed() {
  yield call(LocalStorage.set, LocalStorageKeys.hasDoneBackup, true);
  yield put(keypairActionCreators.setBackup(true));
}

function* handleKeyPressed({ payload: { label, value } }) {
  yield call(navigationRef.navigate, routeNames.fullKey, { label, value });
}

function* handleAddPublicKeyPressed() {
  yield call(navigationRef.navigate, routeNames.addPublicKey);
}

function* handleSavePublicKeyPressed({ payload: { label, publicKey } }) {
  const publicKeys = yield select(keypairSelectors.getPublicKeys);
  const trimmedLabel = label.trim();
  const isUsed = !!publicKeys.find(k => k.label === trimmedLabel);
  if (isUsed) {
    yield put(
      toastActionCreators.setToast(`"${trimmedLabel}" is already used, choose a different name.`)
    );
    return;
  }

  const trimmedPublicKey = publicKey.trim();
  const isValid = yield call(isValidPublicKey, trimmedPublicKey);
  if (!isValid) {
    yield put(toastActionCreators.setToast('Public key is invalid.'));
    return;
  }

  const newKeys = [...publicKeys, { label: label.trim(), publicKey: trimmedPublicKey }];
  yield call(LocalStorage.set, LocalStorageKeys.publicKeys, newKeys);
  yield put(keypairActionCreators.setPublicKeys(newKeys));
  yield put(toastActionCreators.setToast('Added!'));
  yield call(navigationRef.goBack);
}

function* handleDeletePublicKeyPressed({ payload: { label } }) {
  const publicKeys = yield select(keypairSelectors.getPublicKeys);
  const newKeys = publicKeys.filter(p => p.label !== label);
  yield call(LocalStorage.set, LocalStorageKeys.publicKeys, newKeys);
  yield put(keypairActionCreators.setPublicKeys(newKeys));

  const activePublicKey = yield select(keypairSelectors.getActivePublicKeyLabel);
  if (label === activePublicKey) {
    yield call(LocalStorage.remove, LocalStorageKeys.activePublicKey);
    yield put(keypairActionCreators.setActivePublicKey(null));
  }

  yield call(navigationRef.goBack);
}

function* handleChangeActivePublicKeyPressed({ payload: { label } }) {
  yield call(LocalStorage.set, LocalStorageKeys.activePublicKey, label);
  yield put(keypairActionCreators.setActivePublicKey(label));
  if (label) {
    yield put(toastActionCreators.setToast(`You will encrypt for "${label}" from now on.`));
  } else {
    yield put(toastActionCreators.setToast('You will encrypt for yourself from now on.'));
  }
}

function* handleFriendPublicKeyPressed({ payload: { label, publicKey } }) {
  yield call(navigationRef.navigate, routeNames.friendPublicKey, { label, publicKey });
}

export function* keypairSagas() {
  yield fork(initKeys);

  yield all([
    takeLatest(
      keypairActionTypes.NAVIGATE_TO_NEW_KEYPAIR_PRESSED,
      handleNavigateToNewKeypairPressed
    ),
    takeLatest(
      keypairActionTypes.NAVIGATE_TO_EXISTING_KEYPAIR_PRESSED,
      handleNavigateToExistingKeypairPressed
    ),
    takeLatest(keypairActionTypes.PASTE_PUBLIC_KEY_PRESSED, handlePastePublicKeyPressed),
    takeLatest(keypairActionTypes.PASTE_PRIVATE_KEY_PRESSED, handlePastePrivateKeyPressed),
    takeLatest(
      keypairActionTypes.FINISH_ADD_EXISTING_KEYPAIR_PRESSED,
      handleFinishAddExistingKeypairPressed
    ),
    takeLatest(keypairActionTypes.GENERATE_KEYPAIR_PRESSED, handleGenerateKeypairPressed),
    takeLatest(keypairActionTypes.DELETE_KEYPAIR_PRESSED, handleDeleteKeypairPressed),
    takeLatest(
      keypairActionTypes.CONFIRM_DELETE_KEYPAIR_PRESSED,
      handleConfirmDeleteKeypairPressed
    ),
    takeLatest(keypairActionTypes.FINISH_BACKUP_PRESSED, handleFinishBackupPressed),
    takeLatest(keypairActionTypes.KEY_PRESSED, handleKeyPressed),
    takeLatest(keypairActionTypes.ADD_PUBLIC_KEY_PRESSED, handleAddPublicKeyPressed),
    takeLatest(keypairActionTypes.SAVE_PUBLIC_KEY_PRESSED, handleSavePublicKeyPressed),
    takeLatest(keypairActionTypes.DELETE_PUBLIC_KEY_PRESSED, handleDeletePublicKeyPressed),
    takeLatest(
      keypairActionTypes.CHANGE_ACTIVE_PUBLIC_KEY_PRESSED,
      handleChangeActivePublicKeyPressed
    ),
    takeLatest(keypairActionTypes.FRIEND_PUBLIC_KEY_PRESSED, handleFriendPublicKeyPressed),
  ]);
}
